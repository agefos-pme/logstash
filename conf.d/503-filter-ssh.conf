filter {

  if [type] == "ssh-log" {

    grok {
      keep_empty_captures => true
      named_captures_only => true
      break_on_match => true
      patterns_dir => "/opt/logstash/vendor/bundle/jruby/1.9/gems/logstash-patterns-core-0.4.0/patterns/"
      match => { "message" => [ 
        "%{SSH_VALID_INVALID}",
        "%{SSH_PAM_SESSION}",
        "%{SSH_CHECK_PAM_PASSWD}",
        "%{SSH_AUTH_FAILURE}",
        "%{SSH_AUTH_FAILURE_DOMAIN}",
        "%{SSH_CONNECTION_STATE}",
        "%{SSH_DISCONNECT}",
        "%{SSH_DISCONNECTING}",
        "%{SSH_PAM_AUTH_FAILURE}",
        "%{SSH_PAM_MAX_RETRIES}",
        "%{SSH_UNKNOW_USER}",
        "%{SSH_INVALID_USER}",
        "%{SSH_INPUT_USER_AUTH}",
        "%{SSH_CHECK_PASS_AUTH}",
        "%{SSH_SUDO}"
                              ] }
      add_tag => "ssh_groked"
      tag_on_failure => [ "ssh_ungroked" ]
    }

    date {
      match => [ "ssh_timestamp", "MMM  d HH:mm:ss", "MMM dd HH:mm:ss" ]
    }

    mutate {
      gsub => [ "ssh_pam_mechanism", "[\(\)]", "" ]
      remove_field => [ 
        "ssh_program_and_pid",
        "syslog_pri"
                      ]
      rename => [
        "program", "ssh_program",
        "pid", "ssh_pid"
                ] 
      convert => [
         "ssh_authentication_number_attempt_failure", "integer",
         "ssh_pid", "integer",
         "ssh_uid", "integer",
         "ssh_user_uid", "integer",
         "ssh_user_euid", "integer",
         "ssh_port", "integer"
                 ]
    }

    ruby {
      code => "event.to_hash.delete_if {|field, value| value == '' }"
    }

    if "ssh_ungroked" in [tags] {

      mutate {
        add_field => [ "ssh_ungroked_messages", "%{message}" ]
      }
    }
  }
}
