input {

  tcp {
    type => "syslog-reseau"
    port => 514
  }

  udp {
    type => "syslog-reseau"
    port => 514
  }
}

filter {

  if [type] == "syslog-reseau" and [message] =~ "TRAFFIC" {

    mutate {
      update => { "type" => "pa-traffic-log" }
    }
  
    grok { 
      keep_empty_captures => true
      named_captures_only => true
      break_on_match => true
#      patterns_dir => "/opt/logstash/vendor/bundle/jruby/1.9/gems/logstash-patterns-core-0.1.10/patterns/"
      patterns_dir => "/etc/logstash/patterns/"
      match => { "message" => [
        "%{PA_TRAFFIC_MESSAGE_1}",
        "%{PA_TRAFFIC_MESSAGE_2}"
                              ] }
      add_tag => "pa_traffic_groked"
      tag_on_failure => [ "pa_traffic_ungroked" ]
    }

    date {
      match => [ "pa_traffic_timestamp", "MMM  d HH:mm:ss", "MMM dd HH:mm:ss" ]
      timezone => "Europe/Paris"
#      target => [ "pa_traffic_real_timestamp" ]
      target => [ "timestamp_real" ]
    }

    mutate {
      remove_field => [
         "pa_syslog_pri",
         "pa_traffic_timestamp",
         "pa_traffic_receive_timestamp",
         "pa_traffic_generated_timestamp",
         "pa_traffic_session_id_timestamp",
         "pa_traffic_session_start_timestamp",
         "pa_traffic_future_use_1",
         "pa_traffic_future_use_2",
         "pa_traffic_cpadding",
         "pa_traffic_syslog_pri",
         "pa_traffic_future_use_1",
         "pa_future_use_2"
                      ]
      convert => [
        "pa_traffic_bytes_total", "integer",
        "pa_traffic_bytes_sent", "integer",
        "pa_traffic_bytes_received", "integer",
        "pa_traffic_pkts_total", "integer",
        "pa_traffic_pkts_sent", "integer",
        "pa_traffic_pkts_received", "integer",
        "pa_traffic_direction", "integer",
        "pa_traffic_nat_dst_port", "integer",
        "pa_traffic_nat_src_port", "integer",
        "pa_traffic_seq_num", "integer",
        "pa_traffic_serial", "integer",
        "pa_traffic_session_src_port", "integer",
        "pa_traffic_session_dst_port", "integer",
        "pa_traffic_session_elpased_time", "integer",
        "pa_traffic_session_id", "integer",
        "pa_traffic_session_repeat_count", "integer"
                 ]
#      gsub => [ 
#        "pa_traffic_rule", " ", "_",
#        "pa_traffic_application", "( |-)", "_",
#        "pa_traffic_ip_or_host_src", "-", "_"
#              ]
      }

      geoip {
        source => "pa_traffic_dst_ip"
        database => "/etc/logstash/geoip/GeoLiteCity.dat"
        target => "pa_traffic_dst_geoip"
      }

      ruby {
        code => "event.to_hash.delete_if {|field, value| value.nil? }"
      }

      if "pa_traffic_ungroked" in [tags] {

        mutate {
          add_field => [ "pa_traffic_ungroked_messages", "%{message}" ]
        }
      }

  } else if [type] == "syslog-reseau" and [message] =~ "THREAT" {

      mutate {
        update => { "type" => "pa-threat-log" }
      }

    grok {
      keep_empty_captures => true
      named_captures_only => true
      break_on_match => true
#      patterns_dir => "/opt/logstash/vendor/bundle/jruby/1.9/gems/logstash-patterns-core-0.4.0/patterns/paloalto"
      patterns_dir => "/etc/logstash/patterns/"
      match => { "message" => [ "%{PA_THREAT_MESSAGE}" ] }
      add_tag => "pa_threat_groked"
      tag_on_failure => [ "pa_threat_ungroked" ]
    }

    date {
      match => [ "pa_threat_timestamp", "MMM  d HH:mm:ss", "MMM dd HH:mm:ss" ]
      timezone => "Europe/Paris"
      target => [ "pa_threat_real_timestamp" ]
    }

    mutate {
      remove_field => [
         "pa_threat_syslog_pri",
         "pa_threat_timestamp",
         "pa_threat_receive_timestamp",
         "pa_threat_generated_timestamp",
         "pa_threat_session_id_timestamp",
         "pa_threat_future_use_1",
         "pa_threat_future_use_2",
         "pa_threat_undef"
                      ]
      convert => [
        "pa_threat_nat_dst_port", "integer",
        "pa_threat_nat_src_port", "integer",
        "pa_threat_seq_num", "integer",
        "pa_threat_serial", "integer",
        "pa_threat_session_src_port", "integer",
        "pa_threat_session_dst_port", "integer",
        "pa_threat_session_elpased_time", "integer",
        "pa_threat_session_id", "integer",
        "pa_threat_session_repeat_count", "integer"
                 ]
#      gsub => [
#        "pa_threat_ip_or_host_src", "-", "_",
#        "pa_threat_rule", " ", "_",
#        "pa_threat_application", "( |-)", "_",
#        "pa_threat_misc", "(\")", "",
#        "pa_threat_id", "[\(\)]", ""
#              ]
    }

    ruby {
      code => "event.to_hash.delete_if {|field, value| value.nil? }"
    }

    if "pa_threat_ungroked" in [tags] {

      mutate {
        add_field => [ "pa_threat_ungroked_messages", "%{message}" ]
      }
    }

  } else if [type] == "syslog-reseau" and [message] =~ "GET|POST|PUT|DELETE" {

      mutate {
        update => { "type" => "squid-log" }
      }

      grok {
        keep_empty_captures => true
        named_captures_only => true
        break_on_match => true
#        patterns_dir => "/opt/logstash/vendor/bundle/jruby/1.9/gems/logstash-patterns-core-0.1.10/patterns/"
        patterns_dir => "/etc/logstash/patterns/"
        match => { "message" => [ "%{SQUID_MESSAGE}" ] }
        add_tag => "squid_groked"
        tag_on_failure => [ "squid_ungroked" ]
      }

      date {
        match => [ "squid_timestamp", "dd/MM/YYYY HH:mm:ss", " d/MM/YYYY HH:mm:ss" ]
        timezone => "Europe/Paris"
        target => [ "squid_real_timestamp" ]
      }

      mutate {
        remove_field => [
         "squid_timestamp",
         "squid_syslog_program",
         "squid_syslog_pri"
                      ]
        convert => [
         "squid_request_port", "integer",
         "squid_http_version", "float",
         "squid_http_status_code", "integer",
         "squid_cache_value", "integer",
         "squid_bit_transaction", "integer"
                   ]
#        gsub => [
#         "squid_ip_or_host_src", "-", "_",
#         "squid_request_category", " ", "_"
#                ]
      }

      if [squid_request_url] =~ "\b(?:[0-9A-Za-z][0-9A-Za-z-]{0,62})(?:\.(?:[0-9A-Za-z][0-9A-Za-z-]{0,62}))*(\.?|\b)" {

        dns {
          resolve => [ "squid_request_url" ]
          add_field => { "squid_request_url_resolved" => "%{[squid_request_url][-1]}" }
        }

        ruby {
          code => "event['squid_request_url'].pop()"
           }

        mutate {
          join => { "squid_request_url" => "" }
        }

        geoip {
          source => "squid_request_url_resolved"
          database => "/etc/logstash/geoip/GeoLiteCity.dat"
          target => "squid_dst_geoip"
        }
      
      } else {

          geoip {
            source => "squid_request_url"
            database => "/etc/logstash/geoip/GeoLiteCity.dat"
            target => "squid_dst_geoip"
          }
      }

      ruby {
        code => "event.to_hash.delete_if {|field, value| value.nil? }"
      }

      if [type] == "squid-log" and "squid_ungroked" in [tags] { 

        mutate {
          add_field => [ "squid_ungroked_messages", "%{message}" ]
        }
      }

  } else if [type] == "syslog-reseau" and [message] !~ "(TRAFFIC|THREAT)" {

      drop { }
  }
}


output {

  stdout {
    codec => rubydebug
  }

  if [type] == "pa-traffic-log" and "pa_traffic_groked" in [tags] {

    elasticsearch {
#      host => localhost
      hosts => ["clients.elasticsearch"]
      index => "agefos-pa-traffic-%{+YYYY.MM.dd}"
#      protocol => "http"
#      template => "/etc/logstash/templates/pa-traffic.json"
#      template_name => "pa-traffic"
#      template_overwrite => true
#      manage_template => true
    }

   } else if [type] == "pa-traffic-log" and "pa_traffic_ungroked" in [tags] {

    elasticsearch {
#      host => localhost
      hosts => ["clients.elasticsearch"]
      index => "agefos-pa-traffic-ungroked-%{+YYYY.MM.dd}"
#      protocol => "http"
#      template => "/etc/logstash/templates/pa-traffic.json"
#      template_name => "pa-traffic"
#      template_overwrite => true
#      manage_template => true
    }

  } else if [type] == "pa-threat-log" and "pa_threat_groked" in [tags] {

    elasticsearch {
#      host => localhost
      hosts => ["clients.elasticsearch"]
      index => "agefos-pa-threat-%{+YYYY.MM.dd}"
#      protocol => "http"
#      template => "/etc/logstash/templates/pa-threat.json"
#      template_name => "pa-threat"
#      template_overwrite => true
#      manage_template => true
    }

  } else if [type] == "pa-threat-log" and "pa_threat_ungroked" in [tags] {

    elasticsearch {
#      host => localhost
      hosts => ["clients.elasticsearch"]
      index => "agefos-pa-threat-ungroked-%{+YYYY.MM.dd}"
#      protocol => "http"
#      template => "/etc/logstash/templates/pa-threat.json"
#      template_name => "pa-threat"
#      template_overwrite => true
#      manage_template => true
    }

  } else if [type] == "squid-log" and "squid_groked" in [tags] {

    elasticsearch {
#      host => localhost
      hosts => ["clients.elasticsearch"]
      index => "agefos-squid-groked-%{+YYYY.MM.dd}"
#      protocol => "http"
#      template => "/etc/logstash/templates/squid.json"
#      template_name => "squid"
#      template_overwrite => true
#      manage_template => true
    }

  } else if [type] == "squid-log" and "squid_ungroked" in [tags] {

    elasticsearch {
#      host => localhost
      hosts => ["clients.elasticsearch"]
      index => "agefos-squid-ungroked-%{+YYYY.MM.dd}"
#      protocol => "http"
#      template => "/etc/logstash/templates/squid.json"
#      template_name => "squid"
#      template_overwrite => true
#      manage_template => true
    }
  }
}
